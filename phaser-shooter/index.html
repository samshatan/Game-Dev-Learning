<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Phaser Space Shooter</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
  <style>
    body {
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #000;
    }

    canvas {
      border: 2px solid #333;
    }
  </style>
</head>

<body>
  <script>
    const config = {
      type: Phaser.AUTO,
      width: 800,
      height: 600,
      physics: {
        default: 'arcade',
        arcade: {
          gravity: { y: 0 }, // No gravity in space!
          debug: false
        }
      },
      scene: {
        preload: preload,
        create: create,
        update: update
      }
    };

    const game = new Phaser.Game(config);

    function preload() {
      // We will load assets here
      this.load.image('space', 'https://raw.githubusercontent.com/photonstorm/phaser3-examples/master/public/assets/skies/space3.png');
      this.load.image('ship', 'https://raw.githubusercontent.com/photonstorm/phaser3-examples/master/public/assets/sprites/x2kship.png');
      this.load.image('bullet', 'https://raw.githubusercontent.com/photonstorm/phaser3-examples/master/public/assets/sprites/bullets/bullet6.png');
      this.load.image('baddie', 'https://raw.githubusercontent.com/photonstorm/phaser3-examples/master/public/assets/sprites/space-baddie.png')
    }

    let player;
    let cursors;
    let bullets;
    let lastFired = 0;
    let enemies;
    let gameOver = false;
    let scoreText;
    let score = 0;
    let keyR;

    function create() {
      gameOver = false;
      score = 0;
      keyR = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);

      // Background
      this.add.tileSprite(400, 300, 800, 600, 'space');

      // Player Ship
      player = this.physics.add.sprite(400, 500, 'ship');
      player.setCollideWorldBounds(true);
      player.setAngle(-90);

      // Controls
      cursors = this.input.keyboard.createCursorKeys();

      // Score
      scoreText = this.add.text(16, 16, 'Score: 0', { fontSize: '32px', fill: '#FFF' });

      bullets = this.physics.add.group({
        defaultKey: 'bullet',
        maxSize: 10
      })

      enemyBullets = this.physics.add.group({
        defaultKey: 'bullet',
        maxSize: 10
      })

      enemies = this.physics.add.group();
      for (var i = 0; i < 10; i++) {
        var enemy = enemies.create(100 + (i * 60), 100, 'baddie');
        enemy.setCollideWorldBounds(true);
        enemy.setBounce(1);
      }

      this.tweens.add({
        targets: enemies.getChildren(),
        x: '+=200',
        duration: 2000,
        yoyo: true,
        repeat: -1
      })

      this.time.addEvent({
        delay: 2500,
        callback: moveEnemiesDown,
        callbackScope: this,
        loop: true
      });

      this.time.addEvent({
        delay: 1500,
        callback: enemyFire,
        callbackScope: this,
        loop: true
      });

      this.physics.add.collider(bullets, enemies, hitEnemy, null, this);
      this.physics.add.collider(player, enemies, hitPlayer, null, this);
      this.physics.add.overlap(player, enemyBullets, hitPlayer, null, this);
    }

    function update(time, delta) {
      // Player Movement
      player.setVelocity(0);

      if (cursors.left.isDown) {
        player.setVelocityX(-300);
      } else if (cursors.right.isDown) {
        player.setVelocityX(300);
      }

      if (cursors.up.isDown) {
        player.setVelocityY(-300);
      } else if (cursors.down.isDown) {
        player.setVelocityY(300);
      }

      if (cursors.space.isDown && time > lastFired) {
        var bullet = bullets.get(player.x, player.y - 20);
        if (bullet) {
          bullet.setActive(true);
          bullet.setVisible(true);
          bullet.setVelocityY(-400);
          lastFired = time + 150;
        }
        if (gameOver) {
          if (keyR.isDown) {
            this.scene.restart();
            gameOver = false;
            score = 0;
          }
          return;
        }

        bullets.children.iterate(function (child) {
          if (child.active && child.y < -50) {
            child.setActive(false);
            child.setVisible(false);
          }
        });

        enemyBullets.children.iterate(function (child) {
          if (child.active && child.y > 600) {
            child.setActive(false);
            child.setVisible(false);
          }
        });
      }
    }

      function hitEnemy(bullet, enemy) {
        bullet.setActive(false);
        bullet.setVisible(false);
        enemy.disableBody(true, true);
        score += 10;
        scoreText.setText('Score: ' + score);
      }

      function hitPlayer(player, enemy) {
        this.physics.pause();
        player.setTint(0xff0000);
        gameOver = true;
        this.add.text(400, 300, 'GAME OVER\nPress R to Restart', { fontSize: '48px', fill: '#f00', align: 'center' }).setOrigin(0.5);
      }

      function moveEnemiesDown() {
        enemies.children.iterate(function (child) {
          child.y += 40;
        });
      }

      function enemyFire() {
        if (gameOver) {
          return;
        }
        var enemy = Phaser.Utils.Array.GetRandom(enemies.getChildren());
        if (enemy.active) {
          var bullet = enemyBullets.get(enemy.x, enemy.y);
          if (bullet) {
            bullet.setActive(true);
            bullet.setVisible(true);
            bullet.setVelocityY(400);
          }
        }
      }
  </script>
</body>

</html>